<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Add array support for DSL on Minimal CPU | Xi&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="The project is hosted in the repository (section-4):
minimal_CPU
Introduction
Currently, the compiler and DSL support the basic calculation like assigning value, reset value, add and substrction operation. However, there is an important part in the language not being supported. It&rsquo;s array. The purpose of this array is to read and write string with more convenience, and it can be used to construct a mini-terminal or shell to interact with the simulated hardware(CPU).">
<meta name="author" content="Xi Chen">
<link rel="canonical" href="https://xichen1997.github.io/posts/2025-09-19-add-array-support-for-dsl-based-on-minimal-cpu/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.56bf4be95d09faf55cd507c845718ccfcabb2e24e37f8fa5a66f9fa098252b06.css" integrity="sha256-Vr9L6V0J&#43;vVc1QfIRXGMz8q7LiTjf4&#43;lpm&#43;foJglKwY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://xichen1997.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xichen1997.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xichen1997.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xichen1997.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xichen1997.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://xichen1997.github.io/posts/2025-09-19-add-array-support-for-dsl-based-on-minimal-cpu/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
};

window.addEventListener('load', (event) => {
    document.querySelectorAll("mjx-container").forEach(function(x){
      x.parentElement.classList += 'has-jax'})
  });
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<meta property="og:url" content="https://xichen1997.github.io/posts/2025-09-19-add-array-support-for-dsl-based-on-minimal-cpu/">
  <meta property="og:site_name" content="Xi&#39;s Blog">
  <meta property="og:title" content="Add array support for DSL on Minimal CPU">
  <meta property="og:description" content="The project is hosted in the repository (section-4): minimal_CPU
Introduction Currently, the compiler and DSL support the basic calculation like assigning value, reset value, add and substrction operation. However, there is an important part in the language not being supported. It’s array. The purpose of this array is to read and write string with more convenience, and it can be used to construct a mini-terminal or shell to interact with the simulated hardware(CPU).">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-09-19T00:06:00+00:00">
    <meta property="article:modified_time" content="2025-09-19T00:06:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Add array support for DSL on Minimal CPU">
<meta name="twitter:description" content="The project is hosted in the repository (section-4):
minimal_CPU
Introduction
Currently, the compiler and DSL support the basic calculation like assigning value, reset value, add and substrction operation. However, there is an important part in the language not being supported. It&rsquo;s array. The purpose of this array is to read and write string with more convenience, and it can be used to construct a mini-terminal or shell to interact with the simulated hardware(CPU).">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xichen1997.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Add array support for DSL on Minimal CPU",
      "item": "https://xichen1997.github.io/posts/2025-09-19-add-array-support-for-dsl-based-on-minimal-cpu/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Add array support for DSL on Minimal CPU",
  "name": "Add array support for DSL on Minimal CPU",
  "description": "The project is hosted in the repository (section-4): minimal_CPU\nIntroduction Currently, the compiler and DSL support the basic calculation like assigning value, reset value, add and substrction operation. However, there is an important part in the language not being supported. It\u0026rsquo;s array. The purpose of this array is to read and write string with more convenience, and it can be used to construct a mini-terminal or shell to interact with the simulated hardware(CPU).\n",
  "keywords": [
    
  ],
  "articleBody": "The project is hosted in the repository (section-4): minimal_CPU\nIntroduction Currently, the compiler and DSL support the basic calculation like assigning value, reset value, add and substrction operation. However, there is an important part in the language not being supported. It’s array. The purpose of this array is to read and write string with more convenience, and it can be used to construct a mini-terminal or shell to interact with the simulated hardware(CPU).\nBasic Design It’s naturally the array is stored continucious and the head of array is the pointer location, and the index is the distance between the first element of the array.\nThe define of the array require requesting more memory than just one uint_8 memory. Thus, it needs a new instruction, which can be based on the STORE instruction. Inituitively, there should be a special LOAD environment for load the element inside the array.\nAnd it’s has been clear that we need more instructions to apply for the memory like:\nDefine the length of the array, ARRAY_DECL. LOAD_INDEX and STORE_INDEX to load and store value from and to the variables inside the array. Usage examples After adding the array instructions, we should get the usage and examples:\n# Basic array operations let arr[5]; arr[0] = 10; arr[1] = 20; out arr[0]; # Outputs: 10 # Array with variable indices let i = 1; let x = arr[i]; # x = 20 arr[i] = arr[0] + 5; # arr[1] = 15 # Complex expressions let buffer[100]; let size = 10; buffer[0] = size * 2; out buffer[0]; # Outputs: 20 Implementation Add two extra tokens: 1 2 case '[': return {TokenType::OP_LBRACKET, \"[\", startline, startcol}; case ']': return {TokenType::OP_RBRACKET, \"]\", startline, startcol}; Add a mapping from array first element to corresponding space. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 uint16_t Codegen::allocateArrayViaVar(const std::string\u0026 name, uint16_t size) { uint16_t base = allocateVar(name); // get current base DATA_CURSOR += (size - 1); // manually skip full size return base; } // Then add a map to array first location case OpCode::ARRAY_DECL: { // ARRAY_DECL arrayName, arraySize // allocate the array uint16_t arraySize = std::stoi(instruction.arg2); uint16_t arrayAddress = allocateArrayViaVar(instruction.arg1, arraySize); arrMap[instruction.arg1] = {arrayAddress, arraySize}; break; } LOAD_INDEXED and STORE_INDEXED The LOAD_INDEXED and STORE_INDEXED can be translated to normal LOAD_VAR and STORE_VAR because they have no difference:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 case OpCode::LOAD_INDEXED: { uint16_t indexAddr = allocateVar(instruction.arg2); uint16_t resAddr = allocateVar(instruction.result); uint16_t baseAddr = arrMap[instruction.arg1].first; // load index to R2 code.push_back(0x01); code.push_back(0x02); // R2 code.push_back(indexAddr \u003e\u003e 8); // addr high code.push_back(indexAddr \u0026 0xFF); // addr low // Load base address high byte to R0 code.push_back(0x02); code.push_back(0x00); // R0 code.push_back(baseAddr \u003e\u003e 8); // addr high byte only // Load base address low byte to R1 code.push_back(0x02); code.push_back(0x01); // R1 code.push_back(baseAddr \u0026 0xFF); // addr low byte // LOAD_INDEXED uses: R0 (base), R2 (offset), R4 (dst) code.push_back(0x0A); // store result to resAddr code.push_back(0x03); code.push_back(resAddr \u003e\u003e 8); // addr high code.push_back(resAddr \u0026 0xFF); // addr low code.push_back(0x04); // R4 break; } case OpCode::STORE_INDEXED: { // STORE_INDEXED arrayName, index, value // get the array address and size uint16_t indexAddr = allocateVar(instruction.arg2); uint16_t valAddr = allocateVar(instruction.result); uint16_t baseAddr = arrMap[instruction.arg1].first; // load value to R4 code.push_back(0x01); code.push_back(0x04); // R4 code.push_back(valAddr \u003e\u003e 8); // addr high code.push_back(valAddr \u0026 0xFF); // addr low // load index to R2 code.push_back(0x01); code.push_back(0x02); // R2 code.push_back(indexAddr \u003e\u003e 8); // addr high code.push_back(indexAddr \u0026 0xFF); // addr low // Load base address high byte to R0 code.push_back(0x02); code.push_back(0x00); // R0 code.push_back(baseAddr \u003e\u003e 8); // addr high byte only // Load base address low byte to R1 code.push_back(0x02); code.push_back(0x01); // R1 code.push_back(baseAddr \u0026 0xFF); // addr low byte // STORE_INDEXED uses: R0 (hi), R1 (lo), R2 (offset), R4 (src) code.push_back(0x0B); break; } Testing program let arr[5]; arr[1] = 1; arr[2] = 2; arr[4] = 10; out arr[4]; It should return 4, the testing can be easily done by REPL. If verification in cpu simulator level, you can run this section by .runfromCPU ",
  "wordCount" : "718",
  "inLanguage": "en",
  "datePublished": "2025-09-19T00:06:00Z",
  "dateModified": "2025-09-19T00:06:00Z",
  "author":{
    "@type": "Person",
    "name": "Xi Chen"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xichen1997.github.io/posts/2025-09-19-add-array-support-for-dsl-based-on-minimal-cpu/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Xi's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xichen1997.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xichen1997.github.io/" accesskey="h" title="Xi&#39;s Blog (Alt + H)">Xi&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://xichen1997.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://xichen1997.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://xichen1997.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://xichen1997.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://xichen1997.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Add array support for DSL on Minimal CPU
    </h1>
    <div class="post-meta"><span title='2025-09-19 00:06:00 +0000 +0000'>September 19, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>718 words</span>&nbsp;·&nbsp;<span>Xi Chen</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#basic-design">Basic Design</a></li>
    <li><a href="#usage-examples">Usage examples</a></li>
    <li><a href="#implementation">Implementation</a>
      <ul>
        <li><a href="#add-two-extra-tokens">Add two extra tokens:</a></li>
        <li><a href="#add-a-mapping-from-array-first-element-to-corresponding-space">Add a mapping from array first element to corresponding space.</a></li>
        <li><a href="#load_indexed-and-store_indexed">LOAD_INDEXED and STORE_INDEXED</a></li>
      </ul>
    </li>
    <li><a href="#testing-program">Testing program</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>The project is hosted in the repository (section-4):
<a href="https://github.com/xichen1997/minimal_turing_complete_CPU">minimal_CPU</a></p>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>Currently, the compiler and DSL support the basic calculation like assigning value, reset value, add and substrction operation. However, there is an important part in the language not being supported. It&rsquo;s array. The purpose of this array is to read and write string with more convenience, and it can be used to construct a mini-terminal or shell to interact with the simulated hardware(CPU).</p>
<h2 id="basic-design">Basic Design<a hidden class="anchor" aria-hidden="true" href="#basic-design">#</a></h2>
<p>It&rsquo;s naturally the array is stored continucious and the head of array is the pointer location, and the index is the distance between the first element of the array.</p>
<p>The define of the array require requesting more memory than just one uint_8 memory. Thus, it needs a new instruction, which can be based on the STORE instruction. Inituitively, there should be a special LOAD environment for load the element inside the array.</p>
<p>And it&rsquo;s has been clear that we need more instructions to apply for the memory like:</p>
<ul>
<li>Define the length of the array, ARRAY_DECL.</li>
<li>LOAD_INDEX and STORE_INDEX to load and store value from and to the variables inside the array.</li>
</ul>
<h2 id="usage-examples">Usage examples<a hidden class="anchor" aria-hidden="true" href="#usage-examples">#</a></h2>
<p>After adding the array instructions, we should get the usage and examples:</p>
<pre tabindex="0"><code># Basic array operations
let arr[5];
arr[0] = 10;
arr[1] = 20;
out arr[0];        # Outputs: 10

# Array with variable indices
let i = 1;
let x = arr[i];    # x = 20
arr[i] = arr[0] + 5; # arr[1] = 15

# Complex expressions
let buffer[100];
let size = 10;
buffer[0] = size * 2;
out buffer[0];     # Outputs: 20
</code></pre><h2 id="implementation">Implementation<a hidden class="anchor" aria-hidden="true" href="#implementation">#</a></h2>
<h3 id="add-two-extra-tokens">Add two extra tokens:<a hidden class="anchor" aria-hidden="true" href="#add-two-extra-tokens">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">case</span> <span class="sc">&#39;[&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="p">{</span><span class="n">TokenType</span><span class="o">::</span><span class="n">OP_LBRACKET</span><span class="p">,</span> <span class="s">&#34;[&#34;</span><span class="p">,</span> <span class="n">startline</span><span class="p">,</span> <span class="n">startcol</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="sc">&#39;]&#39;</span><span class="o">:</span> <span class="k">return</span> <span class="p">{</span><span class="n">TokenType</span><span class="o">::</span><span class="n">OP_RBRACKET</span><span class="p">,</span> <span class="s">&#34;]&#34;</span><span class="p">,</span> <span class="n">startline</span><span class="p">,</span> <span class="n">startcol</span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="add-a-mapping-from-array-first-element-to-corresponding-space">Add a mapping from array first element to corresponding space.<a hidden class="anchor" aria-hidden="true" href="#add-a-mapping-from-array-first-element-to-corresponding-space">#</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">uint16_t</span> <span class="n">Codegen</span><span class="o">::</span><span class="n">allocateArrayViaVar</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">base</span> <span class="o">=</span> <span class="n">allocateVar</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>  <span class="c1">// get current base
</span></span></span><span class="line"><span class="cl">    <span class="n">DATA_CURSOR</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>          <span class="c1">// manually skip full size
</span></span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Then add a map to array first location
</span></span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="n">OpCode</span><span class="o">::</span><span class="nl">ARRAY_DECL</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ARRAY_DECL arrayName, arraySize
</span></span></span><span class="line"><span class="cl">            <span class="c1">// allocate the array
</span></span></span><span class="line"><span class="cl">            <span class="kt">uint16_t</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">instruction</span><span class="p">.</span><span class="n">arg2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="kt">uint16_t</span> <span class="n">arrayAddress</span> <span class="o">=</span> <span class="n">allocateArrayViaVar</span><span class="p">(</span><span class="n">instruction</span><span class="p">.</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arraySize</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">arrMap</span><span class="p">[</span><span class="n">instruction</span><span class="p">.</span><span class="n">arg1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">arrayAddress</span><span class="p">,</span> <span class="n">arraySize</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="load_indexed-and-store_indexed">LOAD_INDEXED and STORE_INDEXED<a hidden class="anchor" aria-hidden="true" href="#load_indexed-and-store_indexed">#</a></h3>
<p>The LOAD_INDEXED and STORE_INDEXED can be translated to normal LOAD_VAR and STORE_VAR because they have no difference:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">case</span> <span class="n">OpCode</span><span class="o">::</span><span class="nl">LOAD_INDEXED</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">indexAddr</span> <span class="o">=</span> <span class="n">allocateVar</span><span class="p">(</span><span class="n">instruction</span><span class="p">.</span><span class="n">arg2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">resAddr</span> <span class="o">=</span> <span class="n">allocateVar</span><span class="p">(</span><span class="n">instruction</span><span class="p">.</span><span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">baseAddr</span> <span class="o">=</span> <span class="n">arrMap</span><span class="p">[</span><span class="n">instruction</span><span class="p">.</span><span class="n">arg1</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// load index to R2
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span> <span class="c1">// R2
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">indexAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// addr high
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">indexAddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// addr low
</span></span></span><span class="line"><span class="cl">    <span class="c1">// Load base address high byte to R0
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span> <span class="c1">// R0
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">baseAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// addr high byte only
</span></span></span><span class="line"><span class="cl">    <span class="c1">// Load base address low byte to R1  
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span> <span class="c1">// R1
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">baseAddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// addr low byte
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// LOAD_INDEXED uses: R0 (base), R2 (offset), R4 (dst)
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x0A</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// store result to resAddr
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x03</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">resAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// addr high
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">resAddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// addr low
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span> <span class="c1">// R4
</span></span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">case</span> <span class="n">OpCode</span><span class="o">::</span><span class="nl">STORE_INDEXED</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// STORE_INDEXED arrayName, index, value
</span></span></span><span class="line"><span class="cl">    <span class="c1">// get the array address and size
</span></span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">indexAddr</span> <span class="o">=</span> <span class="n">allocateVar</span><span class="p">(</span><span class="n">instruction</span><span class="p">.</span><span class="n">arg2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">valAddr</span> <span class="o">=</span> <span class="n">allocateVar</span><span class="p">(</span><span class="n">instruction</span><span class="p">.</span><span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">baseAddr</span> <span class="o">=</span> <span class="n">arrMap</span><span class="p">[</span><span class="n">instruction</span><span class="p">.</span><span class="n">arg1</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// load value to R4
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x04</span><span class="p">);</span> <span class="c1">// R4
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">valAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// addr high
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">valAddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// addr low
</span></span></span><span class="line"><span class="cl">    <span class="c1">// load index to R2
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span> <span class="c1">// R2
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">indexAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// addr high
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">indexAddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// addr low
</span></span></span><span class="line"><span class="cl">    <span class="c1">// Load base address high byte to R0
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x00</span><span class="p">);</span> <span class="c1">// R0
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">baseAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">// addr high byte only
</span></span></span><span class="line"><span class="cl">    <span class="c1">// Load base address low byte to R1  
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x02</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span> <span class="c1">// R1
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">baseAddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span> <span class="c1">// addr low byte
</span></span></span><span class="line"><span class="cl">    <span class="c1">// STORE_INDEXED uses: R0 (hi), R1 (lo), R2 (offset), R4 (src)
</span></span></span><span class="line"><span class="cl">    <span class="n">code</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mh">0x0B</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="testing-program">Testing program<a hidden class="anchor" aria-hidden="true" href="#testing-program">#</a></h2>
<pre tabindex="0"><code class="language-DSL" data-lang="DSL">let arr[5];
arr[1] = 1;
arr[2] = 2;
arr[4] = 10;
out arr[4];
</code></pre><p>It should return 4, the testing can be easily done by REPL. If verification in cpu simulator level, you can run this section by .runfromCPU &lt;script&gt;.dsl</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://xichen1997.github.io/posts/2025-11-17-introduction-to-cuda-and-high-performance-cuda-kernels/">
    <span class="title">« Prev</span>
    <br>
    <span>Kernel comparison with a MMA in CUDA and near-SOTA/cuBLAS performance kernel</span>
  </a>
  <a class="next" href="https://xichen1997.github.io/posts/2025-07-14-dsl-and-compiler-based-on-minimal-cpu/">
    <span class="title">Next »</span>
    <br>
    <span>DSL and Compiler Based on Minimal CPU</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://xichen1997.github.io/">Xi&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
