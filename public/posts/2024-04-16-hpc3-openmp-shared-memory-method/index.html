<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="dark">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>HPC-3-use-openmp(shared-memory-method) | Xi&#39;s Blog</title>
<meta name="keywords" content="OpenMP, parallel-computing, shared-memory, multi-threading">
<meta name="description" content="Introduction to HPC, shared memory parallel using openmp
1 The multicore system

The relationship with L1-L3 cache. The L3 cache is shared, but every core have its own L1-2 cache.
2 Using openmp


1


#include &#34;omp.h&#34;


Before using it, we need to define how many threads we want to use:
In Unix system:


1


export OMP_NUM_THREADS=4 


The instruction:


1


#pragma omp parallel


If we put this macro before one line of code or one block, the line or block will be executed $OMP_NUM_TRHREADS times.">
<meta name="author" content="Xi Chen">
<link rel="canonical" href="http://localhost:1313/posts/2024-04-16-hpc3-openmp-shared-memory-method/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.56bf4be95d09faf55cd507c845718ccfcabb2e24e37f8fa5a66f9fa098252b06.css" integrity="sha256-Vr9L6V0J&#43;vVc1QfIRXGMz8q7LiTjf4&#43;lpm&#43;foJglKwY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/2024-04-16-hpc3-openmp-shared-memory-method/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
};

window.addEventListener('load', (event) => {
    document.querySelectorAll("mjx-container").forEach(function(x){
      x.parentElement.classList += 'has-jax'})
  });
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Xi&#39;s Blog (Alt + H)">Xi&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      HPC-3-use-openmp(shared-memory-method)
    </h1>
    <div class="post-meta"><span title='2024-04-16 00:05:14 -0400 EDT'>April 16, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>684 words</span>&nbsp;·&nbsp;<span>Xi Chen</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#1-the-multicore-system">1 The multicore system</a></li>
    <li><a href="#2-using-openmp">2 Using openmp</a></li>
    <li><a href="#3-optimization-of-threading">3 optimization of threading</a></li>
    <li><a href="#4-ahmdahls-law">4 Ahmdahl&rsquo;s law</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction-to-hpc-shared-memory-parallel-using-openmp">Introduction to HPC, shared memory parallel using openmp<a hidden class="anchor" aria-hidden="true" href="#introduction-to-hpc-shared-memory-parallel-using-openmp">#</a></h1>
<h2 id="1-the-multicore-system">1 The multicore system<a hidden class="anchor" aria-hidden="true" href="#1-the-multicore-system">#</a></h2>
<p><img alt="image-20200520102045196" loading="lazy" src="https://raw.githubusercontent.com/OeuFcok/picture_for_blog/master/typora/20200520190314.png"></p>
<p>The relationship with L1-L3 cache. The L3 cache is shared, but every core have its own L1-2 cache.</p>
<h2 id="2-using-openmp">2 Using openmp<a hidden class="anchor" aria-hidden="true" href="#2-using-openmp">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;omp.h&#34;</span><span class="cp">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Before using it, we need to define how many threads we want to use:</p>
<p>In Unix system:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">OMP_NUM_THREADS</span><span class="o">=</span><span class="m">4</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>The instruction:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#pragma omp parallel
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If we put this macro before one line of code or one block, the line or block will be executed $OMP_NUM_TRHREADS times.</p>
<p>The instruction:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="cp">#pragma omp parallel for
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>will seperate the for loops into different pieces for threading.</p>
<h2 id="3-optimization-of-threading">3 optimization of threading<a hidden class="anchor" aria-hidden="true" href="#3-optimization-of-threading">#</a></h2>
<p><img alt="image-20200520103006321" loading="lazy" src="https://raw.githubusercontent.com/OeuFcok/picture_for_blog/master/typora/20200520190321.png"></p>
<p>Consider the previous five for-loop, we could use <code>#pragma omp parallel for</code> before one of the for loop. And this is the results of the performance, note the y-axis is GFLOPS/thread.</p>
<p><img alt="Plot_MT_GFLOPS_per_thread_8x6" loading="lazy" src="https://raw.githubusercontent.com/OeuFcok/picture_for_blog/master/typora/20200520190328.png"></p>
<p><strong>Analysis</strong></p>
<p>In MT Loop1, the performance is not good because every core L2 cache must load the submatrix of A. And in this sample, the Mc = 72, Mr=8, that means in every 1st for loop, only $\frac{Mc}{Mr} = 9$ tasks need to be executed by 4 threads, the ratio of tasks over threads is too small. This will cause the imbalance of load. Besides the amortized expense is very large.(Computer system need to do branching and synchronization operation, this will also need time to execute.)</p>
<p>In MT Loop2, the performance is good. The only downside is every core need to store the same $A_{i,p}$ matrix in L2 cache.</p>
<p>In MT Loop3, it is a little tricky. Because only add the parallel instruction, you will not get the right answer. That is because in the code we only have a buffer for Atilde(the packing matrix), but all threads will write to A simutaneously, and the Atilde will not be correct for every one threads. Lucky thing is that if the size of this loop (m/Mc) is not large, we could apply for extra matrix, and every thread will have its own Atilde.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="c1">// Code loop 3
</span></span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">LoopThree</span><span class="p">(</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ldA</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">Btilde</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">C</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ldC</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="o">*</span><span class="n">Atilde</span> <span class="o">=</span> <span class="p">(</span> <span class="kt">double</span> <span class="o">*</span> <span class="p">)</span> <span class="n">_mm_malloc</span><span class="p">(</span> <span class="n">MC</span> <span class="o">*</span> <span class="n">KC</span> <span class="o">*</span> <span class="n">omp_get_max_threads</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span> <span class="kt">double</span> <span class="p">),</span> <span class="mi">64</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">       
</span></span><span class="line"><span class="cl">  <span class="cp">#pragma omp parallel for
</span></span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">MC</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ib</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">MC</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="n">i</span> <span class="p">);</span>    <span class="cm">/* Last loop may not involve a full block */</span>
</span></span><span class="line"><span class="cl">    <span class="n">PackBlockA_MCxKC</span><span class="p">(</span> <span class="n">ib</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alpha</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">ldA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Atilde</span><span class="p">[</span> <span class="n">MC</span> <span class="o">*</span> <span class="n">KC</span> <span class="o">*</span> <span class="n">omp_get_thread_num</span><span class="p">()</span> <span class="p">]</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">LoopTwo</span><span class="p">(</span> <span class="n">ib</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Atilde</span><span class="p">[</span> <span class="n">MC</span> <span class="o">*</span> <span class="n">KC</span> <span class="o">*</span> <span class="n">omp_get_thread_num</span><span class="p">()</span> <span class="p">],</span> <span class="n">Btilde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gamma</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span><span class="mi">0</span> <span class="p">),</span> <span class="n">ldC</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">_mm_free</span><span class="p">(</span> <span class="n">Atilde</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In MT Loop4, this algorithm is not correct. Because every threads will write to the matrix simutaneously. The C can&rsquo;t accumulate, this will lead to the error. Of course you could make another matrix to store the value temporarily, but it is too expensive.</p>
<p>In MT Loop5, the performance will change with the quotient $\frac{n}{N_C}$.</p>
<h2 id="4-ahmdahls-law">4 Ahmdahl&rsquo;s law<a hidden class="anchor" aria-hidden="true" href="#4-ahmdahls-law">#</a></h2>
<p>Consider a sequential algorithm that solves the problem in time $T$.</p>
<p>Suppose a fraction $f$ of this work cannot be parallelized, while the remaining $1-f$ scales perfectly across $t$ threads. The total time with $t$ threads becomes</p>
<p>$$</p>
<p>\begin{equation*}
T_t = \frac{(1-f)T}{t} + fT = T\left(f + \frac{1-f}{t}\right)
\end{equation*}</p>
<p>$$</p>
<p>and it is immediate that $T_t \geq fT$.</p>
<p>For matrix multiplication we can write the sequential cost as
$$</p>
<p>\begin{equation*}
T(n) = 2 n^3 \gamma + C n^2 \beta
\end{equation*}</p>
<p>$$
so the parallel execution time is
$$</p>
<p>\begin{equation*}
T_t(n) = \frac{2 n^3 \gamma}{t} + C n^2 \beta
\end{equation*}</p>
<p>$$
The speedup coefficient is therefore
$$</p>
<p>\begin{equation*}
S_t(n) = \frac{T(n)}{T_t(n)} = \frac{2 n^3 \gamma + C n^2 \beta}{\frac{2 n^3 \gamma}{t} + C n^2 \beta}
\end{equation*}</p>
<p>$$
and the efficiency simplifies to
$$</p>
<p>\begin{equation*}
E_t(n) = \frac{S_t(n)}{t} = \frac{2 n^3 \gamma + C n^2 \beta}{2 n^3 \gamma + t C n^2 \beta}
\end{equation*}</p>
<p>$$
As $n \to \infty$, the lower-order term involving $C n^2 \beta$ vanishes and $E_t(n) \to 1$: larger problem sizes deliver higher efficiency.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/openmp/">OpenMP</a></li>
      <li><a href="http://localhost:1313/tags/parallel-computing/">Parallel-Computing</a></li>
      <li><a href="http://localhost:1313/tags/shared-memory/">Shared-Memory</a></li>
      <li><a href="http://localhost:1313/tags/multi-threading/">Multi-Threading</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/2024-07-21-when-chatgpt-will-let-you-down-after-6-hours-on-a-project/">
    <span class="title">« Prev</span>
    <br>
    <span>When ChatGPT will let you down?After 6 hours on a project</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/2023-04-14-hpc1-divide-and-conquer-block-matrix/">
    <span class="title">Next »</span>
    <br>
    <span>HPC-1-divide-and-conquer-block-matrix-algorithmr</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="http://localhost:1313/">Xi&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
